"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.twClassesSerializer = exports.twClassesGenerator = exports.twClassesParser = exports.twClassesComposer = void 0;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function will return a Array of tailwind classes.
 * Docs + example: https://github.com/Arthie/tailwindcssinjs/tree/master/packages/class-composer#1-twclassescomposer
 */
function twClassesComposer(separator) {
    if (typeof separator !== "string") {
        throw new Error(`Separator "${separator}" must be of type String`);
    }
    const NOT_WHITE_SPACE_REGEX = /\S+/g;
    // captures variant arrays syntax =>  sm:hover[text-red-100 bg-blue-200]
    const VARIANT_ARRAY_SYNTAX_REGEX = new RegExp(`(\\S+(?:\\${separator}\\w+)?)\\[((?:.|\\n)*?)\\]`, "g");
    // captures nested angle brackets => [[]]
    const NESTED_ANGLE_BRACKET_REGEXP = /(\[([^\[\]]){0,}\[)|(\]([^\[\]]){0,}\])/g;
    /**
     * replaces variant array syntax to regular tailwind class syntax
     * sm:hover[text-red-100 bg-blue-200] => sm:hover:text-red-100 sm:hover:bg-blue-200
     */
    const variantArraySyntaxReplacer = (_substring, ...searchResult) => {
        var _a;
        // searchResult contains substring capture groups
        const [variant, variantclasses] = searchResult;
        // matches tailwind classes and removes whitespace
        // " text-red-100  bg-blue-200 " => ["text-red-100", "bg-blue-200"]
        const twClasses = (_a = variantclasses.match(NOT_WHITE_SPACE_REGEX)) !== null && _a !== void 0 ? _a : [];
        const replacementClasses = [];
        for (const twClass of twClasses) {
            replacementClasses.push(`${variant}${separator}${twClass}`);
        }
        return replacementClasses.join(" ");
    };
    return (...twClasses) => {
        var _a;
        // combines all arguments into a string
        // @ts-expect-error - typescript Array type is broken: lib.es2019.array.d.ts:23:5 - error TS2502: '"recur"' is referenced directly or indirectly in its own type annotation.
        const twClassesString = twClasses.flat(Infinity).join(" ");
        if (NESTED_ANGLE_BRACKET_REGEXP.test(twClassesString)) {
            throw new Error(`Nested variant arrays are not allowed`);
        }
        // replaces variant array syntax
        const replacedTwClassesString = twClassesString.replace(VARIANT_ARRAY_SYNTAX_REGEX, variantArraySyntaxReplacer);
        // matches tailwind classes and removes whitespace
        // " text-red-100  bg-blue-200 " => ["text-red-100", "bg-blue-200"]
        const composedTwClasses = Array.from((_a = replacedTwClassesString.match(NOT_WHITE_SPACE_REGEX)) !== null && _a !== void 0 ? _a : []);
        //Remove duplicate classes
        return Array.from(new Set(composedTwClasses.reverse())).reverse();
    };
}
exports.twClassesComposer = twClassesComposer;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function will return an array of class and variants tuples.
 * Docs + example: https://github.com/Arthie/tailwindcssinjs/tree/master/packages/class-composer#2-twclassesvariantsparser
 */
function twClassesParser(separator) {
    const composer = twClassesComposer(separator);
    return (...twClasses) => {
        const composedTwClasses = composer(twClasses);
        const parsedClasses = [];
        for (const composedTwClass of composedTwClasses) {
            const [twClass, ...variants] = composedTwClass.split(separator).reverse();
            parsedClasses.push([twClass, variants]);
        }
        return parsedClasses;
    };
}
exports.twClassesParser = twClassesParser;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function takes an array of parsed tailwind classes and return an Array of tailwind classes.
 */
function twClassesGenerator(separator) {
    return (parsedTwClasses) => {
        const twClasses = [];
        for (const [twClass, variants] of parsedTwClasses) {
            if (variants.length) {
                twClasses.push(variants.reverse().join(separator) + separator + twClass);
            }
            else {
                twClasses.push(twClass);
            }
        }
        return twClasses;
    };
}
exports.twClassesGenerator = twClassesGenerator;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function will return a tailwind classes string
 * Docs + example: https://github.com/Arthie/tailwindcssinjs/tree/master/packages/class-composer#3-twclassesserializer
 */
function twClassesSerializer(separator) {
    const composer = twClassesComposer(separator);
    return (...twClasses) => composer(twClasses).join(" ");
}
exports.twClassesSerializer = twClassesSerializer;
function default_1(separator, variants) {
    if (variants) {
        for (const variant of variants) {
            if (variant.includes(separator)) {
                throw new Error(`Variant name: "${variant}" can't contain separator: "${separator}"`);
            }
        }
    }
    return {
        composer: twClassesComposer(separator),
        parser: twClassesParser(separator),
        serializer: twClassesSerializer(separator),
        generator: twClassesGenerator(separator),
    };
}
exports.default = default_1;
//# sourceMappingURL=classComposer.js.map