"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const babel_plugin_macros_1 = require("babel-plugin-macros");
const corePlugins_1 = __importDefault(require("tailwindcss/lib/corePlugins"));
const tailwindcssConfig_1 = require("@tailwindcssinjs/tailwindcss-data/lib/tailwindcssConfig");
const class_composer_1 = require("@tailwindcssinjs/class-composer");
const tailwindcssinjs_1 = __importDefault(require("./tailwindcssinjs"));
const devCorePluginsGenerator_1 = require("./devCorePluginsGenerator");
/**
 * Returns tailwind classes from macro arguments
 * @param path
 */
function getArgs(path) {
    if (path.type === "CallExpression") {
        const node = path;
        return node.get("arguments").map((item) => item.evaluate().value);
    }
    if (path.type === "TaggedTemplateExpression") {
        const node = path;
        const quasi = node.get("quasi");
        const templateElements = quasi
            .get("quasis")
            .map((item) => item.node.value.raw);
        const expressions = quasi
            .get("expressions")
            .map((item) => item.evaluate().value);
        const twClasses = [];
        while (templateElements.length || expressions.length) {
            const twClassString = templateElements.shift();
            const twClassObject = expressions.shift();
            if (twClassString) {
                twClasses.push(twClassString);
            }
            if (twClassObject) {
                twClasses.push(twClassObject);
            }
        }
        return twClasses;
    }
    throw new Error("Invalid Nodepath");
}
/**
 * Add development imports to the file this enables hot reloading on config changes
 *
 * Example imports:
 * import tailwindconfig from "ABSULUTEPATH/tailwind.config";
 * import devCorePluginsCreator from "@tailwindcssinjs/macro/lib/devCorePluginsCreator"
 * import tailwindcssinjs from "@tailwindcssinjs/macro/lib/tailwindcssinjs";
 * const tw = tailwindcssinjs(tailwindconfig, devCorePluginsCreator);
 * @param referencePath
 * @param t
 * @param state
 */
function addDevImports(referencePath, t, state) {
    //check if file already has dev imports
    if (!state.tailwindDevTwUid) {
        //create tailwindconfig importDeclaration:
        //import tailwindconfig from "ABSULUTEPATH/tailwind.config";
        const tailwindConfigUid = referencePath.scope.generateUidIdentifier("tailwindconfig");
        const tailwindConfigImport = t.importDeclaration([t.importDefaultSpecifier(tailwindConfigUid)], t.stringLiteral(state.tailwindConfigPath
            ? state.tailwindConfigPath
            : "tailwindcss/defaultConfig"));
        //create devCorePluginsCreator importDeclaration:
        //import devCorePluginsCreator from "@tailwindcssinjs/macro/lib/devCorePluginsCreator"
        const devCorePluginsCreatorUid = referencePath.scope.generateUidIdentifier("devCorePluginsCreator");
        const corePluginsImport = t.importDeclaration([t.importDefaultSpecifier(devCorePluginsCreatorUid)], t.stringLiteral("@tailwindcssinjs/macro/lib/devCorePluginsCreator"));
        //create tailwindcssinjs importDeclaration:
        //import tailwindcssinjs from "@tailwindcssinjs/macro/lib/tailwindcssinjs";
        const tailwindcssinjsUid = referencePath.scope.generateUidIdentifier("tailwindcssinjs");
        const tailwindcssinjsImport = t.importDeclaration([t.importDefaultSpecifier(tailwindcssinjsUid)], t.stringLiteral("@tailwindcssinjs/macro/lib/tailwindcssinjs"));
        //create tw variableDeclaration:
        //const tw = tailwindcssinjs(tailwindconfig, devCorePluginsCreator);
        const twUid = referencePath.scope.generateUidIdentifier("tw");
        const twConst = t.variableDeclaration("const", [
            t.variableDeclarator(twUid, t.callExpression(tailwindcssinjsUid, [
                tailwindConfigUid,
                devCorePluginsCreatorUid,
            ])),
        ]);
        //store uids in state
        state.tailwindDevTwUid = twUid;
        //add devImports nodes to the file
        //@ts-expect-error fix type
        state.file.path.node.body.unshift(tailwindConfigImport, corePluginsImport, tailwindcssinjsImport, twConst);
    }
}
/**
 * tries to get tailwind config and stores config in state
 * if it fails it stores default config in state
 * @param state
 * @param config
 */
function getTailwindConfig(state, config) {
    try {
        state.tailwindConfigPath = tailwindcssConfig_1.resolveTailwindConfigPath(config);
        return tailwindcssConfig_1.requireTailwindConfig(state.tailwindConfigPath);
    }
    catch (err) {
        return tailwindcssConfig_1.requireTailwindConfig(); //returns default config
    }
}
function tailwindcssinjsMacro({ references: { default: paths }, state, babel: { types: t }, config, }) {
    var _a, _b, _c, _d;
    try {
        state.configPath = (_a = config === null || config === void 0 ? void 0 : config.config) !== null && _a !== void 0 ? _a : "./tailwind.config.js";
        state.developmentMode = (_b = config === null || config === void 0 ? void 0 : config.developmentMode) !== null && _b !== void 0 ? _b : true;
        state.isDev =
            process.env.NODE_ENV === "development" && state.developmentMode;
        state.tailwindConfig = getTailwindConfig(state, state.configPath);
        const serializer = class_composer_1.twClassesSerializer((_d = (_c = state.tailwindConfig) === null || _c === void 0 ? void 0 : _c.separator) !== null && _d !== void 0 ? _d : ":");
        if (state.isDev) {
            devCorePluginsGenerator_1.generateDevCorePlugins();
        }
        else {
            state.tailwind = tailwindcssinjs_1.default(state.tailwindConfig, corePlugins_1.default);
        }
        paths.forEach((referencePath) => {
            const args = getArgs(referencePath.parentPath);
            if (state.isDev) {
                addDevImports(referencePath, t, state);
                const serialisedArgs = serializer(args);
                if (state.tailwindDevTwUid) {
                    const replacementAst = t.callExpression(state.tailwindDevTwUid, [
                        t.stringLiteral(serialisedArgs),
                    ]);
                    referencePath.parentPath.replaceWith(replacementAst);
                }
            }
            else if (state.tailwind) {
                const style = state.tailwind(args);
                referencePath.parentPath.replaceWith(t.valueToNode(style));
            }
        });
    }
    catch (err) {
        err.message = `@tailwindcssinjs/macro - ${err.message}`;
        throw new babel_plugin_macros_1.MacroError(err);
    }
}
exports.default = babel_plugin_macros_1.createMacro(tailwindcssinjsMacro, {
    configName: "tailwindcssinjs",
});
//# sourceMappingURL=macro.js.map