"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeObjectStyles = exports.transformTwRootToObjectStyle = void 0;
//@ts-expect-error postcss-js has no type definition
const postcss_js_1 = require("postcss-js");
const merge_1 = __importDefault(require("lodash/merge"));
const sort_css_media_queries_1 = __importDefault(require("sort-css-media-queries"));
const postcss_selector_parser_1 = __importDefault(require("postcss-selector-parser"));
function transformTwRootToObjectStyle(twClass, twRoot) {
    const processor = postcss_selector_parser_1.default((root) => {
        root.walkClasses((node) => {
            var _a;
            if ((_a = node.value) === null || _a === void 0 ? void 0 : _a.endsWith(twClass)) {
                node.replaceWith(postcss_selector_parser_1.default.nesting({}));
            }
        });
    });
    const root = twRoot.clone();
    root.walkRules((rule) => {
        if (!rule.nodes) {
            throw new Error(`Rule has no nodes ${root}`);
        }
        rule.selector = processor.processSync(rule.selector);
        if (rule.selector === "&") {
            rule.replaceWith(rule.nodes);
        }
    });
    return postcss_js_1.objectify(root);
}
exports.transformTwRootToObjectStyle = transformTwRootToObjectStyle;
function sortObjectStyle(objectStyle) {
    const objectStyleEntries = Object.entries(objectStyle);
    //also sort nested style Rules / atRules
    for (const [index, [key, value]] of objectStyleEntries.entries()) {
        if (typeof value === "object" && !Array.isArray(value)) {
            const sortedValue = sortObjectStyle(value);
            objectStyleEntries[index] = [key, sortedValue];
        }
    }
    const getValueType = (key, value) => {
        const type = typeof value;
        if (type === "string") {
            if (key.startsWith("--")) {
                return "declVariable";
            }
            return "decl";
        }
        if (type === "object") {
            if (Array.isArray(value)) {
                return "declArray";
            }
            if (key.startsWith("@")) {
                return "atRule";
            }
            return "rule";
        }
        if (type === "number") {
            return "decl";
        }
        throw new Error(`This type: ${type} of value: ${value} is not supported`);
    };
    const sortedObjectStyleEntries = objectStyleEntries.sort(([first, firstValue], [second, secondValue]) => {
        const firstValueType = getValueType(first, firstValue);
        const secondValueType = getValueType(second, secondValue);
        const firstIsDecl = firstValueType.startsWith("decl");
        const secondIsDecl = secondValueType.startsWith("decl");
        if (firstIsDecl && secondIsDecl) {
            const firstIsCssVar = firstValueType === "declVariable";
            const secondIsCssVar = secondValueType === "declVariable";
            if (firstValueType && secondIsCssVar)
                return 0;
            if (firstIsCssVar)
                return -1;
            if (secondIsCssVar)
                return 1;
            return 0;
        }
        if (firstIsDecl)
            return -1;
        if (secondIsDecl)
            return 1;
        const firstIsAtRule = firstValueType === "atRule";
        const secondIsAtRule = secondValueType === "atRule";
        if (firstIsAtRule && secondIsAtRule) {
            return sort_css_media_queries_1.default(first, second);
        }
        if (firstIsAtRule) {
            return 1;
        }
        if (secondIsAtRule) {
            return -1;
        }
        return 0;
    });
    return Object.fromEntries(sortedObjectStyleEntries);
}
function mergeObjectStyles(objectStyles) {
    const mergedObjectStyle = merge_1.default({}, ...objectStyles);
    return sortObjectStyle(mergedObjectStyle);
}
exports.mergeObjectStyles = mergeObjectStyles;
//# sourceMappingURL=transformTwRootToObjectStyle.js.map