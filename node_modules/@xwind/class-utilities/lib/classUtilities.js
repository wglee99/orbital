"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializer = exports.generator = exports.parser = exports.composer = void 0;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function will return a Array of tailwind classes.
 */
function composer(twClasses, separator) {
  var _a;
  if (typeof separator !== "string") {
    throw new Error(`Separator "${separator}" must be of type String`);
  }
  const NOT_WHITE_SPACE_REGEX = /\S+/g;
  // captures variant arrays syntax =>  sm:hover[text-red-100 bg-blue-200]
  const VARIANT_ARRAY_SYNTAX_REGEX = new RegExp(
    `(\\S+(?:\\${separator}\\w+)?)\\[((?:.|\\n)*?)\\]`,
    "g"
  );
  // captures nested angle brackets => [[]]
  const NESTED_ANGLE_BRACKET_REGEXP = /(\[([^\[\]]){0,}\[)|(\]([^\[\]]){0,}\])/g;
  /**
   * replaces variant array syntax to regular tailwind class syntax
   * sm:hover[text-red-100 bg-blue-200] => sm:hover:text-red-100 sm:hover:bg-blue-200
   */
  const variantArraySyntaxReplacer = (_substring, ...searchResult) => {
    var _a;
    // searchResult contains substring capture groups
    const [variant, variantclasses] = searchResult;
    // matches tailwind classes and removes whitespace
    // " text-red-100  bg-blue-200 " => ["text-red-100", "bg-blue-200"]
    const twClasses =
      (_a = variantclasses.match(NOT_WHITE_SPACE_REGEX)) !== null &&
      _a !== void 0
        ? _a
        : [];
    const replacementClasses = [];
    for (const twClass of twClasses) {
      replacementClasses.push(`${variant}${separator}${twClass}`);
    }
    return replacementClasses.join(" ");
  };
  // combines all arguments into a string
  const twClassesString =
    typeof twClasses === "string"
      ? twClasses
      : twClasses.flat(Infinity).join(" ");
  if (NESTED_ANGLE_BRACKET_REGEXP.test(twClassesString)) {
    throw new Error(`Nested variant arrays are not allowed`);
  }
  // replaces variant array syntax
  const replacedTwClassesString = twClassesString.replace(
    VARIANT_ARRAY_SYNTAX_REGEX,
    variantArraySyntaxReplacer
  );
  // matches tailwind classes and removes whitespace
  // " text-red-100  bg-blue-200 " => ["text-red-100", "bg-blue-200"]
  const composedTwClasses =
    (_a = replacedTwClassesString.match(NOT_WHITE_SPACE_REGEX)) !== null &&
    _a !== void 0
      ? _a
      : [];
  //Remove first of duplicate classes
  return Array.from(new Set(composedTwClasses.reverse())).reverse();
}
exports.composer = composer;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function will return an array of class and variants tuples.
 */
function parser(twClasses, separator) {
  const composedTwClasses = composer(twClasses, separator);
  const twParsedClasses = [];
  for (const composedTwClass of composedTwClasses) {
    const splitTwClass = composedTwClass.split(separator);
    const twClass = splitTwClass.pop();
    if (!twClass) continue;
    twParsedClasses.push({
      twClass,
      variants: splitTwClass.reverse(),
    });
  }
  return twParsedClasses;
}
exports.parser = parser;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function takes an array of parsed tailwind classes and return an Array of tailwind classes.
 */
function generator(twParsedClasses, separator) {
  const generateTwClass = (twParsedClass) => {
    var _a;
    if (
      (_a = twParsedClass.variants) === null || _a === void 0
        ? void 0
        : _a.length
    ) {
      return [...twParsedClass.variants.reverse(), twParsedClass.twClass].join(
        separator
      );
    } else {
      return twParsedClass.twClass;
    }
  };
  const twClasses = [];
  if (!Array.isArray(twParsedClasses)) {
    twClasses.push(generateTwClass(twParsedClasses));
  } else {
    for (const twParsedClass of twParsedClasses.flat(Infinity)) {
      twClasses.push(generateTwClass(twParsedClass));
    }
  }
  //Remove first of duplicate classes
  return Array.from(new Set(twClasses.reverse())).reverse();
}
exports.generator = generator;
/**
 * Takes a separator string (e.g. ":") as parameter and returns a composer function.
 * The composer function will return a tailwind classes string
 */
function serializer(twClasses, separator) {
  return composer(twClasses, separator).join(" ");
}
exports.serializer = serializer;
function classUtilities(separator, variants) {
  for (const variant of variants !== null && variants !== void 0
    ? variants
    : []) {
    if (variant.includes(separator)) {
      throw new Error(
        `Variant name: "${variant}" can't contain separator: "${separator}"`
      );
    }
  }
  return {
    composer: (...twClasses) => composer(twClasses, separator),
    parser: (...twClasses) => parser(twClasses, separator),
    serializer: (...twClasses) => serializer(twClasses, separator),
    generator: (...twParsedClasses) => generator(twParsedClasses, separator),
  };
}
exports.default = classUtilities;
//# sourceMappingURL=classUtilities.js.map
