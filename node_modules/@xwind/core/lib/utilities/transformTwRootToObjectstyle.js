"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeObjectstyles = exports.transformTwRootToObjectstyle = void 0;
//@ts-expect-error postcss-js has no type definition
const postcss_js_1 = require("postcss-js");
const merge_1 = __importDefault(require("lodash/merge"));
const sort_css_media_queries_1 = __importDefault(
  require("sort-css-media-queries")
);
const postcss_selector_parser_1 = __importDefault(
  require("postcss-selector-parser")
);
function transformTwRootToObjectstyle(twClass, twRoot) {
  const processor = postcss_selector_parser_1.default((root) => {
    root.walkClasses((node) => {
      var _a;
      if (
        (_a = node.value) === null || _a === void 0
          ? void 0
          : _a.endsWith(twClass)
      ) {
        node.replaceWith(postcss_selector_parser_1.default.nesting({}));
      }
    });
  });
  const root = twRoot.clone();
  root.walkRules((rule) => {
    if (!rule.nodes) {
      throw new Error(`Rule has no nodes ${root}`);
    }
    rule.selector = processor.processSync(rule.selector);
    if (rule.selector === "&") {
      rule.replaceWith(rule.nodes);
    }
  });
  return postcss_js_1.objectify(root);
}
exports.transformTwRootToObjectstyle = transformTwRootToObjectstyle;
function sortObjectstyle(objectStyle) {
  const objectStyleEntries = Object.entries(objectStyle);
  //also sort nested style Rules / atRules
  for (const [index, [key, value]] of objectStyleEntries.entries()) {
    if (typeof value === "object" && !Array.isArray(value)) {
      const sortedValue = sortObjectstyle(value);
      objectStyleEntries[index] = [key, sortedValue];
    }
  }
  const getValueType = (key, value) => {
    const type = typeof value;
    if (type === "string") {
      if (key.startsWith("--")) {
        return "declVariable";
      }
      return "decl";
    }
    if (type === "object") {
      if (Array.isArray(value)) {
        return "declArray";
      }
      if (key.startsWith("@")) {
        return "atRule";
      }
      return "rule";
    }
    if (type === "number") {
      return "decl";
    }
    throw new Error(`This type: ${type} of value: ${value} is not supported`);
  };
  const sortedObjectstyleEntries = objectStyleEntries.sort(
    ([first, firstValue], [second, secondValue]) => {
      const firstValueType = getValueType(first, firstValue);
      const secondValueType = getValueType(second, secondValue);
      const firstIsDecl = firstValueType.startsWith("decl");
      const secondIsDecl = secondValueType.startsWith("decl");
      if (firstIsDecl && secondIsDecl) {
        const firstIsCssVar = firstValueType === "declVariable";
        const secondIsCssVar = secondValueType === "declVariable";
        if (firstValueType && secondIsCssVar) return 0;
        if (firstIsCssVar) return -1;
        if (secondIsCssVar) return 1;
        return 0;
      }
      if (firstIsDecl) return -1;
      if (secondIsDecl) return 1;
      const firstIsAtRule = firstValueType === "atRule";
      const secondIsAtRule = secondValueType === "atRule";
      if (firstIsAtRule && secondIsAtRule) {
        return sort_css_media_queries_1.default(first, second);
      }
      if (firstIsAtRule) {
        return 1;
      }
      if (secondIsAtRule) {
        return -1;
      }
      return 0;
    }
  );
  return Object.fromEntries(sortedObjectstyleEntries);
}
function mergeObjectstyles(objectStyles) {
  const mergedObjectstyle = merge_1.default({}, ...objectStyles);
  return sortObjectstyle(mergedObjectstyle);
}
exports.mergeObjectstyles = mergeObjectstyles;
//# sourceMappingURL=transformTwRootToObjectstyle.js.map
