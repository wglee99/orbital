"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const chokidar_1 = __importDefault(require("chokidar"));
const core_1 = require("@babel/core");
const tailwindConfig_1 = require("./tailwindConfig");
const tailwind_1 = __importDefault(require("./classes/tailwind"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
const xwindConfig_1 = require("./xwindConfig");
const cache = new Map();
const VERSION = "0.0.1";
async function run(program) {
  try {
    const { config, watch } = program.opts();
    const twConfigPath = tailwindConfig_1.getTwConfigPath(config);
    let twConfig = tailwindConfig_1.getTwConfig(twConfigPath);
    let xwindConfig = xwindConfig_1.resolveXwindClassesModeConfig(
      twConfigPath,
      twConfig
    );
    let getTailwindCSS = tailwind_1.default(
      twConfig,
      xwindConfig.classes.includeBase
    );
    const entries = [];
    if (typeof xwindConfig.classes.entry === "string") {
      entries.push(`${xwindConfig.classes.entry}/**/*.+(js|mjs|jsx|ts|tsx)`);
    } else if (Array.isArray(xwindConfig.classes.entry)) {
      for (const entry of xwindConfig.classes.entry) {
        entries.push(`${entry}/**/*.+(js|mjs|jsx|ts|tsx)`);
      }
    }
    const writeCSS = async (classes) => {
      if (!classes) return;
      await new Promise((resolve, reject) => {
        const css = getTailwindCSS(classes);
        const output = xwindConfig.classes.output;
        if (!fs_1.default.existsSync(output)) {
          reject(`Output css file does not exist. path:${output}`);
        }
        fs_1.default.writeFile(output, css, (err) => {
          err && reject(err);
          if (xwindConfig.classes.includeBase) {
            console.log(
              `SUCCES: base css + ${
                classes.join(" ").split(" ").length
              } unique classes written to file "${output}"`
            );
          } else {
            console.log(
              `SUCCES: ${
                classes.join(" ").split(" ").length
              } unique classes written to file "${output}"`
            );
          }
          resolve(null);
        });
      }).catch((err) => console.log(`ERROR: ${err.message}`));
    };
    const getWatchedFiles = (watcher) => {
      const REGEX = /.+\.(js|mjs|jsx|ts|tsx)$/;
      const files = [];
      for (const [dirPath, watched] of Object.entries(watcher.getWatched())) {
        if (!watched.length) continue;
        for (const item of watched) {
          REGEX.test(item) && files.push(path_1.default.resolve(dirPath, item));
        }
      }
      return files;
    };
    let hash = "";
    const getCacheClasses = () => {
      const classes = [...cache.values()];
      const newHash = utils_1.getHash(classes.join());
      if (hash !== newHash) {
        hash = newHash;
        return classes;
      }
    };
    const getClassesFromFile = async (filePath) => {
      try {
        const result = await core_1
          .transformFileAsync(filePath, {
            plugins: [["xwind/babel", { config: twConfigPath }]],
          })
          .catch((err) => console.log(err));
        if (!result || !result.metadata) return;
        const metadata = result.metadata;
        if (!metadata.xwind) return;
        return metadata.xwind;
      } catch (err) {
        console.log(err);
      }
    };
    const watcher = chokidar_1.default.watch(entries, {
      ignored: /(^|[\/\\])\../,
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 50,
        pollInterval: 10,
      },
    });
    await new Promise((resolve) => {
      watcher.on("ready", async () => {
        const files = getWatchedFiles(watcher);
        const classes = [];
        for (const filename of files) {
          const xwind = await getClassesFromFile(filename);
          if (!xwind) continue;
          classes.push(xwind);
          cache.set(filename, xwind);
        }
        await writeCSS(classes);
        resolve(null);
      });
    });
    if (!watch) {
      process.exit(0);
    }
    const configWatcher = chokidar_1.default.watch(twConfigPath, {
      persistent: true,
      awaitWriteFinish: {
        stabilityThreshold: 50,
        pollInterval: 10,
      },
    });
    configWatcher.on("change", async (filePath) => {
      twConfig = tailwindConfig_1.getTwConfig(filePath);
      xwindConfig = xwindConfig_1.resolveXwindClassesModeConfig(
        twConfigPath,
        twConfig
      );
      getTailwindCSS = tailwind_1.default(
        twConfig,
        xwindConfig.classes.includeBase
      );
      hash = "";
      await writeCSS(getCacheClasses());
    });
    configWatcher.on("unlink", async (filePath) => {
      throw new Error(`Config file not found at path: "${filePath}"`);
    });
    for (const type of ["add", "change"]) {
      watcher.on(type, async (filename) => {
        const xwind = await getClassesFromFile(filename);
        if (!xwind) return;
        cache.set(path_1.default.resolve(filename), xwind);
        writeCSS(getCacheClasses());
      });
    }
    watcher.on("unlink", async (filename) => {
      cache.delete(path_1.default.resolve(filename));
      await writeCSS(getCacheClasses());
    });
  } catch (err) {
    console.log(err);
  }
}
async function main() {
  await commander_1.program
    .version(VERSION)
    .option(
      "-c, --config <path>",
      "path to tailwind.config.js",
      "./tailwind.config.js"
    )
    .option("-w, --watch", "watch files", false)
    .parseAsync(process.argv);
  await run(commander_1.program);
}
main();
//# sourceMappingURL=cli.js.map
