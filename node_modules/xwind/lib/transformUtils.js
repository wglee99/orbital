"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCachedTransformer = exports.getArgs = void 0;
const class_utilities_1 = __importDefault(require("@xwind/class-utilities"));
const core_1 = __importStar(require("@xwind/core"));
const tailwindConfig_1 = require("./tailwindConfig");
const xwindConfig_1 = require("./xwindConfig");
function getArgs(referencePath) {
    if (!referencePath.isIdentifier()) {
        throw new Error("Reference path is not identifier");
    }
    const twClasses = [];
    const path = referencePath.parentPath;
    if (path.isCallExpression()) {
        const argumentPaths = path.get("arguments");
        if (Array.isArray(argumentPaths)) {
            for (const argumentPath of argumentPaths) {
                const { confident, value } = argumentPath.evaluate();
                if (!confident)
                    throw new Error(`Value of "${argumentPath.getSource()}" could not be statically evaluated.`);
                twClasses.push(value);
            }
        }
    }
    if (path.isTaggedTemplateExpression()) {
        const quasiPath = path.get("quasi");
        if (!Array.isArray(quasiPath)) {
            const { confident, value } = quasiPath.evaluate();
            if (!confident)
                throw new Error(`Value of "${quasiPath.getSource()}" could not be statically evaluated.`);
            twClasses.push(value);
        }
    }
    return twClasses;
}
exports.getArgs = getArgs;
let $transfromer;
function getCachedTransformer(twConfigPath) {
    const { twConfig, isNewTwConfig } = tailwindConfig_1.getTwConfigCache(twConfigPath);
    if (!$transfromer || isNewTwConfig) {
        const xwConfig = xwindConfig_1.resolveXwindConfig(twConfigPath, twConfig);
        const { screens, variants, baseRoot, componentsRoot, utilitiesRoot, generateTwClassSubstituteRoot, } = core_1.default(twConfig);
        const twClassesUtils = class_utilities_1.default(twConfig.separator, [
            ...screens,
            ...variants,
        ]);
        if (xwConfig.mode === "classes") {
            $transfromer = function transformClasses(paths, state, t) {
                const twClasses = [];
                for (const path of paths) {
                    const args = getArgs(path);
                    const serializedTwClasses = twClassesUtils.serializer(args);
                    path.parentPath.replaceWith(t.stringLiteral(serializedTwClasses));
                    twClasses.push(serializedTwClasses);
                }
                //@ts-expect-error
                state.file.metadata.xwind = twClassesUtils.serializer(twClasses);
            };
        }
        if (xwConfig.mode === "objectstyles") {
            const twClassDictionary = {
                XWIND_BASE: core_1.createTwClassDictionary(baseRoot).XWIND_GLOBAL,
                ...core_1.createTwClassDictionary(componentsRoot, utilitiesRoot),
            };
            const tailwindObjectstyles = (twClasses) => {
                var _a, _b;
                const parsedTwClasses = twClassesUtils.parser(twClasses);
                const composedTwClasses = twClassesUtils.composer(twClasses);
                const objectstyles = [];
                for (const parsedTwClass of parsedTwClasses) {
                    const twRoot = generateTwClassSubstituteRoot(twClassDictionary, parsedTwClass);
                    objectstyles.push(core_1.transformTwRootToObjectstyle(parsedTwClass.twClass, twRoot));
                }
                let objectstyle = core_1.mergeObjectstyles(objectstyles);
                if ((_b = (_a = twConfig.xwind) === null || _a === void 0 ? void 0 : _a.objectstyles) === null || _b === void 0 ? void 0 : _b.plugins) {
                    for (const plugin of twConfig.xwind.objectstyles.plugins) {
                        objectstyle = plugin(objectstyle, composedTwClasses, twConfig);
                    }
                }
                return objectstyle;
            };
            $transfromer = (paths, state, t) => {
                for (const path of paths) {
                    const args = getArgs(path);
                    const objectstyles = tailwindObjectstyles(args);
                    path.parentPath.replaceWith(t.valueToNode(objectstyles));
                }
            };
        }
    }
    return $transfromer;
}
exports.getCachedTransformer = getCachedTransformer;
//# sourceMappingURL=transformUtils.js.map