"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@babel/core");
const tailwindConfig_1 = require("../tailwindConfig");
const babel_1 = __importDefault(require("../babel"));
const xwindConfig_1 = require("../xwindConfig");
const utils_1 = require("../utils");
const fs_1 = __importDefault(require("fs"));
const tailwind_1 = __importDefault(require("../classes/tailwind"));
const class_utilities_1 = require("@xwind/class-utilities");
const cache = new Map();
let $classesHash = "";
let $getTailwindCSS;
function loader(source, sourceMap) {
    var _a, _b, _c, _d, _e;
    this.async();
    const loaderOptions = typeof this.query === "string" ? {} : this.query;
    const twConfigPath = tailwindConfig_1.getTwConfigPath((_a = loaderOptions.config) !== null && _a !== void 0 ? _a : "./tailwind.config.js");
    //remove from cache
    cache.delete(this.resourcePath);
    if (typeof source !== "string") {
        this.callback(null, source, sourceMap);
        return;
    }
    //no need to transform file if it doesn't include xwind
    if (source.indexOf("xwind") === -1) {
        this.callback(null, source, sourceMap);
        return;
    }
    const transformResult = transform(source, sourceMap, {
        resourcePath: this.resourcePath,
        babelOptions: (_b = loaderOptions.babel) !== null && _b !== void 0 ? _b : {},
    });
    this.addDependency(twConfigPath);
    this.callback(null, transformResult.code, (_c = transformResult.map) !== null && _c !== void 0 ? _c : undefined);
    if (!((_d = transformResult.metadata) === null || _d === void 0 ? void 0 : _d.xwind)) {
        return;
    }
    const xwindClasses = transformResult.metadata.xwind;
    const { isNewTwConfig, twConfig } = tailwindConfig_1.getTwConfigCache(twConfigPath);
    const xwindConfig = xwindConfig_1.resolveXwindConfig(twConfigPath, twConfig);
    if (xwindConfig.mode !== "classes") {
        return;
    }
    cache.set(this.resourcePath, xwindClasses);
    const classes = class_utilities_1.composer([...cache.values()], twConfig.separator).sort((a, b) => (a > b ? 0 : -1));
    const newHash = utils_1.getHash(classes.join());
    if ($classesHash === newHash) {
        return;
    }
    $classesHash = newHash;
    if (!$getTailwindCSS || isNewTwConfig) {
        $getTailwindCSS = tailwind_1.default(twConfig, (_e = xwindConfig.classes.includeBase) !== null && _e !== void 0 ? _e : true);
    }
    const css = $getTailwindCSS(classes);
    const output = xwindConfig.classes.output;
    if (!fs_1.default.existsSync(output)) {
        this.emitError(`Output css file does not exist. path:${output}`);
        return;
    }
    fs_1.default.writeFileSync(output, css);
}
exports.default = loader;
function transform(source, sourceMap, { babelOptions, resourcePath, }) {
    const ast = core_1.parseSync(source, {
        ...babelOptions,
        filename: resourcePath,
        caller: { name: "xwind" },
    });
    if (!ast) {
        throw new Error(`XWIND: could not parse ${resourcePath}.`);
    }
    const transformResult = core_1.transformFromAstSync(ast, source, {
        filename: resourcePath,
        plugins: [babel_1.default],
        babelrc: false,
        configFile: false,
        sourceMaps: true,
        sourceFileName: resourcePath,
        inputSourceMap: sourceMap,
    });
    if (!transformResult || !transformResult.code) {
        throw new Error(`XWIND: could not transform ${resourcePath}.`);
    }
    const metadata = transformResult === null || transformResult === void 0 ? void 0 : transformResult.metadata;
    return {
        code: transformResult.code,
        metadata,
        map: transformResult.map,
    };
}
//# sourceMappingURL=loader.js.map